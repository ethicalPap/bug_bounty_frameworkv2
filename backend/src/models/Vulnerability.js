// backend/src/models/Vulnerability.js
const knex = require('../config/database');

class Vulnerability {
  static get tableName() {
    return 'vulnerabilities';
  }

  static async findAll(organizationId, filters = {}) {
    try {
      let query = knex(this.tableName)
        .join('targets', 'vulnerabilities.target_id', 'targets.id')
        .leftJoin('subdomains', 'vulnerabilities.subdomain_id', 'subdomains.id')
        .where('targets.organization_id', organizationId)
        .select(
          'vulnerabilities.*',
          'targets.domain as target_domain',
          'subdomains.subdomain'
        );
      
      if (filters.target_id) {
        query = query.where('vulnerabilities.target_id', filters.target_id);
      }
      
      if (filters.subdomain_id) {
        query = query.where('vulnerabilities.subdomain_id', filters.subdomain_id);
      }
      
      if (filters.severity) {
        query = query.where('vulnerabilities.severity', filters.severity);
      }
      
      if (filters.status) {
        query = query.where('vulnerabilities.status', filters.status);
      }
      
      const sortBy = filters.sortBy || 'created_at';
      const sortOrder = filters.sortOrder || 'desc';
      query = query.orderBy(`vulnerabilities.${sortBy}`, sortOrder);
      
      if (filters.limit) {
        query = query.limit(filters.limit);
      }
      
      if (filters.offset) {
        query = query.offset(filters.offset);
      }
      
      return await query;
    } catch (error) {
      console.log('Vulnerabilities table not yet created, returning empty array');
      return [];
    }
  }

  static async count(organizationId, filters = {}) {
    try {
      let query = knex(this.tableName)
        .join('targets', 'vulnerabilities.target_id', 'targets.id')
        .where('targets.organization_id', organizationId);
      
      if (filters.target_id) {
        query = query.where('vulnerabilities.target_id', filters.target_id);
      }
      
      if (filters.severity) {
        query = query.where('vulnerabilities.severity', filters.severity);
      }
      
      const result = await query.count('vulnerabilities.id as count').first();
      return parseInt(result.count);
    } catch (error) {
      return 0;
    }
  }

  static async bulkCreate(vulnerabilities) {
    if (vulnerabilities.length === 0) return [];
    
    try {
      return await knex(this.tableName)
        .insert(vulnerabilities.map(vuln => ({
          ...vuln,
          created_at: new Date(),
          updated_at: new Date()
        })))
        .onConflict(['target_id', 'title', 'url'])
        .ignore();
    } catch (error) {
      console.log('Could not create vulnerabilities - table may not exist yet');
      return [];
    }
  }

  static async update(id, organizationId, data) {
    try {
      const [vulnerability] = await knex(this.tableName)
        .join('targets', 'vulnerabilities.target_id', 'targets.id')
        .where('targets.organization_id', organizationId)
        .where('vulnerabilities.id', id)
        .update({
          ...data,
          updated_at: new Date()
        })
        .returning('*');
      return vulnerability;
    } catch (error) {
      return null;
    }
  }

  static async getStatsByTarget(organizationId) {
    try {
      return await knex(this.tableName)
        .join('targets', 'vulnerabilities.target_id', 'targets.id')
        .where('targets.organization_id', organizationId)
        .select(
          'targets.id as target_id',
          'targets.domain as target_domain',
          knex.raw('COUNT(vulnerabilities.id) as total_vulnerabilities'),
          knex.raw("COUNT(CASE WHEN vulnerabilities.severity = 'critical' THEN 1 END) as critical_vulns"),
          knex.raw("COUNT(CASE WHEN vulnerabilities.severity = 'high' THEN 1 END) as high_vulns"),
          knex.raw("COUNT(CASE WHEN vulnerabilities.severity = 'medium' THEN 1 END) as medium_vulns"),
          knex.raw("COUNT(CASE WHEN vulnerabilities.severity = 'low' THEN 1 END) as low_vulns")
        )
        .groupBy('targets.id', 'targets.domain');
    } catch (error) {
      return [];
    }
  }
}

module.exports = Vulnerability;